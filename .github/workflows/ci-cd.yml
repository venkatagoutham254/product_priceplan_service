# GitHub Actions workflow for building and smoke-deploying the Spring-Boot service with Maven & Docker Compose
# Triggers only after a successful merge / push to the `main` branch.

name: CI / CD

on:
  push:
    branches: [ "main" ]

jobs:
  build-test-deploy:
    runs-on: ubuntu-latest

    steps:
      # 1. Checkout source code
      - name: Checkout
        uses: actions/checkout@v4

      # 2. Set up JDK for Maven build
      - name: Set up Temurin JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: "temurin"
          java-version: "21"
          cache: "maven"

      # 3. Build project & run unit-tests
      - name: Build with Maven
        working-directory: ./
        run: mvn -B clean install

      # 4. Build Docker images & start full stack (app + database)
      - name: Build & start stack with Docker Compose
        working-directory: ./
        run: docker compose -f docker-compose.yml up --build -d

      # 5. (Optional) Wait for the application to become healthy / reachable
      - name: Wait until API is reachable
        working-directory: ./
        run: |
          echo "Waiting for service to respond on http://localhost:8080/actuator/health â€¦"
          for i in {1..30}; do
            if curl -fs http://localhost:8080/actuator/health > /dev/null 2>&1; then
              echo "Service is up!" && exit 0
            fi
            sleep 5
          done
          echo "Service did not become healthy in time." && docker compose logs && exit 1

      # 6. (Optional) Run integration tests here if you have any
      # - name: Integration tests
      #   run: mvn verify -Pintegration-tests

      # 7. Tear down stack no matter what (collecting logs keeps workflow output tidy)
      - name: Shutdown stack & collect logs on failure
        if: always()
        working-directory: ./
        run: |
          docker compose logs || true
          docker compose down --remove-orphans
